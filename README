# Minitalk

<div align="center">
  <img src="https://img.shields.io/badge/Language-C-blue" alt="Language">
  <img src="https://img.shields.io/badge/School-42-black" alt="42">
  <img src="https://img.shields.io/badge/Norminette-passing-success" alt="Norminette">
</div>

## ğŸ“– Description

**Minitalk** est un projet de communication client-serveur utilisant les signaux UNIX. Le systÃ¨me utilise une liste chaÃ®nÃ©e pour stocker les messages et implÃ©mente un mÃ©canisme d'accusÃ© de rÃ©ception bit par bit.

## ğŸ—ï¸ Architecture

### ğŸ“¡ Serveur (`server.c`)
- Affiche son PID au dÃ©marrage
- Utilise une liste chaÃ®nÃ©e pour stocker les messages
- Reconstruit les caractÃ¨res bit par bit
- Envoie un SIGUSR1 pour confirmer chaque bit reÃ§u
- Envoie un SIGUSR2 quand le message complet est reÃ§u

### ğŸ“± Client (`client.c`)
- Prend en paramÃ¨tres le PID du serveur et le message Ã  envoyer
- Envoie les caractÃ¨res bit par bit
- Attend l'accusÃ© de rÃ©ception pour chaque bit
- Utilise une variable globale `g_received` pour la synchronisation

## ğŸ”§ Protocole de communication

| Signal | ReprÃ©sentation | Usage |
|--------|----------------|-------|
| `SIGUSR1` | Bit `1` | Transmission de donnÃ©es + AccusÃ© de rÃ©ception |
| `SIGUSR2` | Bit `0` | Transmission de donnÃ©es + Fin de message |

### Structure des donnÃ©es
```c
typedef struct s_node
{
    char            data;
    struct s_node   *next;
}   t_node;

typedef struct s_list
{
    t_node  *head;
    t_node  *tail;
    void    *data;
}   t_list;
```

## ğŸš€ Installation et utilisation

```bash
# Compiler
make

# Lancer le serveur
./server
# Le serveur affiche son PID
PID : xxxxx

# Dans un autre terminal, envoyer un message
./client [PID_SERVER] "Votre message"
```

### Compilation et rÃ¨gles du Makefile

```bash
# Compilation complÃ¨te (client et serveur)
make

# Compilation des versions bonus
make bonus

# Nettoyer les fichiers objets
make clean

# Nettoyer tous les fichiers gÃ©nÃ©rÃ©s (objets et exÃ©cutables)
make fclean

# Recompiler tout le projet
make re

# Lancer les tests automatiques
make test

# VÃ©rifier les fuites mÃ©moire avec Valgrind
make valgrind
```

### Tests automatiques
La rÃ¨gle `make test` va :
- Compiler le projet
- Lancer le serveur en arriÃ¨re-plan
- Envoyer un message de test
- Nettoyer les processus

### Analyse mÃ©moire
La rÃ¨gle `make valgrind` permet de :
- Lancer le serveur sous Valgrind
- Tester le client sous Valgrind
- GÃ©nÃ©rer des logs dÃ©taillÃ©s dans :
  - `valgrind_server.log`
  - `valgrind_client.log`

### Utilisation basique

```bash
# Lancer le serveur
./server
# Le serveur affiche son PID
PID : xxxxx

# Dans un autre terminal, envoyer un message
./client [PID_SERVER] "Votre message"
```

// ...existing code...

## ğŸ“ Structure du projet

```
minitalk/
â”œâ”€â”€ server.c
â”œâ”€â”€ client.c
â”œâ”€â”€ list/
â”‚   â”œâ”€â”€ list.c
â”‚   â””â”€â”€ list.h
â””â”€â”€ ft_printf
```

## ğŸ” FonctionnalitÃ©s

### âœ… ImplÃ©mentÃ©es
- Communication via SIGUSR1 et SIGUSR2
- Affichage du PID serveur
- AccusÃ© de rÃ©ception bit par bit
- Gestion des messages via liste chaÃ®nÃ©e
- Une seule variable globale (g_received)

### ğŸ› ï¸ Gestion des erreurs
- VÃ©rification du PID serveur
- Validation des arguments
- Gestion des erreurs de kill()
- Protection contre les erreurs d'allocation mÃ©moire

## ğŸ“‹ Usage

```bash
# DÃ©marrer le serveur
./server
PID : 12345

# Envoyer un message
./client 12345 "Hello World"

# Le serveur affiche :
Hello World
```

## ğŸ‘¨â€ğŸ’» Auteur

DÃ©veloppÃ© par hfandres dans le cadre du cursus de l'Ã©cole 42.

---

<div align="center">
  <i>Made with â¤ï¸ at 42 School</i>
</div>